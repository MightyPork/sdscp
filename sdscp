#!/bin/env python3

import sys
import argparse
import math
import re
import traceback

from macros import MacroProcessor
from tokens import Tokenizer
from readers import CodeReader

# ==================== Command Line Arguments processing =======================

parser = argparse.ArgumentParser(description='SDS-C macro preprocessor')

parser.add_argument(
	'source',
	help='The source file to process'
)

parser.add_argument(
	'-o', '--output',
	help='The output file. To just print the output, use -d'
)

parser.add_argument(
		'-c', '--clean',
		action='store_true',
		default=False,
		help='Remove some whitespace and all comments'
)

parser.add_argument(
		'-v', '--verbose',
		action='store_true',
		default=False,
		help='Show all optional debug info.'
)
parser.add_argument(
		'-s', '--show-source',
		action='store_true',
		default=False,
		help='Show original source (only main file)'
)
parser.add_argument(
		'-m', '--show-macros',
		action='store_true',
		default=False,
		help='List all macros'
)
parser.add_argument(
		'-r', '--show-resolved',
		action='store_true',
		default=False,
		help='Show code after processing includes and # branching.'
)
parser.add_argument(
		'-p', '--show-processed',
		action='store_true',
		default=False,
		help='Show code after replacing macros (preprocessor output)'
)
parser.add_argument(
		'-t', '--show-tokens',
		action='store_true',
		default=False,
		help='Show tokenization.'
)
parser.add_argument(
		'-d', '--show-output',
		action='store_true',
		default=False,
		help='Show the final source (D stands for Display)'
)

args = parser.parse_args()


SRC = args.source
DEST = args.output

SHOW_TOKENS = args.verbose or args.show_tokens

SHOW_PROCESSED = args.verbose or args.show_processed
SHOW_RESOLVED = args.verbose or args.show_resolved

SHOW_MACROS = args.verbose or args.show_macros
SHOW_SOURCE = args.verbose or args.show_source
SHOW_SOURCE = args.verbose or args.show_source
SHOW_OUTPUT = args.verbose or args.show_output

DO_CLEAN = args.clean


# ==================== Utils =======================


def banner(text, fill='-', length=80):
	""" Show a banner line """
	blob = (fill*length + ' ' + text + ' ' + fill*length)
	overlap = len(blob)-80
	print('\n' + blob[ math.floor(overlap/2) : math.floor(-overlap/2)] + '\n')


def prep4disp(code):
	c = '  ' + re.sub(r'\n', '\n  ', code)
	c = re.sub(r'\t', '    ', c)
	return c


def prepare_for_sdsc(code):
	""" Do some finishing touches to the syntax """
	rd = CodeReader(code)

	out = ''

	while not rd.has_end():

		if rd.has_inline_comment():
			out += rd.consume_inline_comment()
			continue

		elif rd.has_block_comment():
			out += rd.consume_block_comment()
			continue

		elif rd.has_string():
			# collect whole string
			# convert quotes to apos
			s = rd.consume_string()
			s = s[1:-1]

			if s.count("'") > 0:
				raise SyntaxError('Sorry, SDS-C compiler is TOO STUPID to handle \' in string.')

			s = re.sub(r'\\"', '"', s)

			out += "'%s'" % s
			continue

		elif rd.has_char():
			# collect whole char literal
			out += rd.consume_char()
			continue

		elif rd.has_identifier():
			# remove empty paren after function name
			out += rd.consume_identifier()
			out += rd.consume_whitespace()

			if rd.has_paren():
				pp = rd.get_pos()
				paren = rd.consume_block()

				if re.match(r'\(\s*\)', paren):
					after = rd.consume_whitespace()
					if rd.has_code_block():
						# omit the empty paren
						out += after
					else:
						out += paren
						out += after
				else:
					rd.move_to(pp) # go back

			elif rd.has_bracket():
				# collect whole bracket

				br = rd.consume_block()
				br_in = br[1:-1].strip()

				if re.match(r'^\([a-zA-Z_][a-zA-Z0-9_]*\)$', br_in):
					br_in = br_in[1:-1]
				elif re.match(r'^\((?:0x|0b)?[0-9]+\)$', br_in):
					br_in = br_in[1:-1]
				elif re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', br_in):
					pass
				elif re.match(r'^(?:0x|0b)?[0-9]+$', br_in):
					pass
				else:
					raise SyntaxError('Sorry, %s appears to be invalid array index for SDS-C.' % br_in)

				out += '[%s]' % br_in

			continue

		else:
			# any other char is just used the same
			out += rd.consume()

	return out



# ==================== MAIN TASK =======================

try:

	banner('SDS-C Plus', ':')

	print('Reading file:', SRC)

	# read the file
	mp = MacroProcessor(SRC)
	mp.keep_comments = not DO_CLEAN

	if SHOW_SOURCE:
		banner('SOURCE', '-')
		print(prep4disp( mp.source ) + '\n')

	# ---------------- Resolve directives ------------------


	# include files, resolve branching, find macros...
	mp.process()


	if SHOW_MACROS:
		banner('MACROS', '-')
		print('List of all found macros, in definition order:\n')
		for d in mp.get_defines().values():
			for m in d:
				print('  ' + str(m))
		print()



	if SHOW_RESOLVED:
		banner('RESOLVED', '-')
		print('Code after resolving includes, # branching, and extracting macros:\n')
		print(prep4disp( mp.get_output() ) + '\n')


	# -------------------- Apply macros --------------------

	# perform macro replacements
	mp.apply_macros()
	# get output code
	processed = mp.get_output()


	if SHOW_PROCESSED:
		banner('PROCESSED', '-')
		print('Code after replacing macros:\n')

		print(prep4disp(processed) + '\n')


	if SHOW_TOKENS:
		banner('TOKENIZED', '-')
		print('Tokenization of the processed code:\n')

		tk = Tokenizer(processed)
		tk.tokenize()
		tk.show()
		print('')


	if DEST != None or SHOW_OUTPUT:
		# perform tweaks to match some of SDS-C's broken syntax
		for_sds = prepare_for_sdsc(processed)

		if SHOW_OUTPUT:
			banner('OUTPUT SDS-C CODE', '-')
			print(prep4disp(for_sds) + '\n')

		if DEST != None:
			print('Writing to file: %s' % DEST)
			f = open(DEST, 'w')
			f.write(for_sds)
			f.close()
		else:
			print('[!] No output file specified.')


	print('\nDone.\n')

except SyntaxError as e:
	banner('SYNTAX ERROR', '#')
	type_, value_, traceback_ = sys.exc_info()
	ex = traceback.format_exception(type_, value_, traceback_)
	for line in ex:
		# discard useless junk
		if 'raise SyntaxError' in line:
			continue
		if 'File "<string>", line None' in line:
			continue

		print(line)

